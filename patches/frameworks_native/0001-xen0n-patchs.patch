From a75880a468146c85e6b36178b1a7e87f4839730b Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Fri, 3 Nov 2017 12:44:19 +0300
Subject: [PATCH] xen0n patchs

Change-Id: Iadaadfadf355f38eb7d40d04faa95716b0131511
---
 include/gui/BufferItem.h                           |   4 +-
 include/gui/BufferItemConsumer.h                   |  21 +-
 include/gui/BufferQueue.h                          | 317 ++++++++++++++++++++-
 include/gui/BufferQueueConsumer.h                  |   2 +-
 include/gui/BufferQueueCore.h                      |   4 +-
 include/gui/BufferQueueProducer.h                  |   1 +
 include/gui/ConsumerBase.h                         |  31 +-
 include/gui/CpuConsumer.h                          |  17 ++
 include/gui/GLConsumer.h                           |   5 +-
 include/gui/IGraphicBufferConsumer.h               |  73 ++++-
 include/gui/SensorManager.h                        |  17 ++
 include/ui/Fence.h                                 |   5 +
 include/ui/GraphicBufferMapper.h                   |   9 +
 include/ui/mediatek/IDumpTunnel.h                  |  49 ++++
 include/ui/mediatek/RefBaseDump.h                  |  63 ++++
 libs/binder/Android.mk                             |   1 +
 libs/binder/MediatekHacks.cpp                      |   7 +
 libs/gui/Android.mk                                |   1 +
 libs/gui/BufferItem.cpp                            |  61 ++--
 libs/gui/BufferItemConsumer.cpp                    |  26 +-
 libs/gui/BufferQueue.cpp                           | 166 +++++++++--
 libs/gui/BufferQueueConsumer.cpp                   |  18 +-
 libs/gui/ConsumerBase.cpp                          |  21 +-
 libs/gui/CpuConsumer.cpp                           |  18 +-
 libs/gui/GLConsumer.cpp                            |  11 +-
 libs/gui/IGraphicBufferConsumer.cpp                | 164 ++++++++++-
 libs/gui/MediatekHacks.cpp                         |  16 ++
 libs/gui/SensorManager.cpp                         |  26 ++
 libs/gui/StreamSplitter.cpp                        |   2 +-
 libs/gui/tests/BufferQueue_test.cpp                |  10 +-
 libs/ui/Android.mk                                 |  17 +-
 libs/ui/GraphicBufferMapper.cpp                    |  22 ++
 libs/ui/mediatek/Fence.cpp                         |  59 ++++
 libs/ui/mediatek/IDumpTunnel.cpp                   | 114 ++++++++
 libs/ui/mediatek/RefBaseDump.cpp                   | 111 ++++++++
 libs/ui/mediatek/test/Android.mk                   |   1 +
 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk |  15 +
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp   | 105 +++++++
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.h     |  17 ++
 opengl/libs/EGL/eglApi.cpp                         |   4 +
 .../DisplayHardware/FramebufferSurface.cpp         |   2 +-
 .../DisplayHardware/VirtualDisplaySurface.cpp      |   2 +-
 services/surfaceflinger/DisplayUtils.cpp           |   5 +
 services/surfaceflinger/Layer.h                    |   6 +-
 services/surfaceflinger/SurfaceFlingerConsumer.cpp |  14 +-
 services/surfaceflinger/SurfaceFlingerConsumer.h   |   3 +-
 46 files changed, 1523 insertions(+), 140 deletions(-)
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/binder/MediatekHacks.cpp
 create mode 100644 libs/gui/MediatekHacks.cpp
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp
 create mode 100755 libs/ui/mediatek/test/Android.mk
 create mode 100755 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h

diff --git a/include/gui/BufferItem.h b/include/gui/BufferItem.h
index 145efe6..354bb8f 100644
--- a/include/gui/BufferItem.h
+++ b/include/gui/BufferItem.h
@@ -23,7 +23,7 @@
 #include <ui/Rect.h>
 #include <ui/Region.h>
 
-#include <system/graphics.h>
+#include <gui/IGraphicBufferConsumer.h>
 
 #include <utils/Flattenable.h>
 #include <utils/StrongPointer.h>
@@ -45,7 +45,9 @@ class BufferItem : public Flattenable<BufferItem> {
     // The default value of mBuf, used to indicate this doesn't correspond to a slot.
     enum { INVALID_BUFFER_SLOT = -1 };
     BufferItem();
+    BufferItem(const IGraphicBufferConsumer::BufferItem& item);
     ~BufferItem();
+    operator IGraphicBufferConsumer::BufferItem() const;
 
     static const char* scalingModeName(uint32_t scalingMode);
 
diff --git a/include/gui/BufferItemConsumer.h b/include/gui/BufferItemConsumer.h
index 56c7a3f..8d016b7 100644
--- a/include/gui/BufferItemConsumer.h
+++ b/include/gui/BufferItemConsumer.h
@@ -42,6 +42,8 @@ class BufferItemConsumer: public ConsumerBase
   public:
     typedef ConsumerBase::FrameAvailableListener FrameAvailableListener;
 
+    typedef BufferQueue::BufferItem BufferItem;
+
     enum { DEFAULT_MAX_BUFFERS = -1 };
     enum { INVALID_BUFFER_SLOT = BufferQueue::INVALID_BUFFER_SLOT };
     enum { NO_BUFFER_AVAILABLE = BufferQueue::NO_BUFFER_AVAILABLE };
@@ -74,7 +76,9 @@ class BufferItemConsumer: public ConsumerBase
     //
     // If waitForFence is true, and the acquired BufferItem has a valid fence object,
     // acquireBuffer will wait on the fence with no timeout before returning.
-    status_t acquireBuffer(BufferItem* item, nsecs_t presentWhen,
+    status_t acquireBuffer(BufferQueue::BufferItem *item, nsecs_t presentWhen,
+            bool waitForFence = true);
+    status_t acquireBuffer(android::BufferItem* item, nsecs_t presentWhen,
             bool waitForFence = true);
 
     // Returns an acquired buffer to the queue, allowing it to be reused. Since
@@ -86,6 +90,21 @@ class BufferItemConsumer: public ConsumerBase
     status_t releaseBuffer(const BufferItem &item,
             const sp<Fence>& releaseFence = Fence::NO_FENCE);
 
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // requestBuffers when a with and height of zero is requested.
+    status_t setDefaultBufferSize(uint32_t w, uint32_t h);
+
+    // setDefaultBufferFormat allows the BufferQueue to create
+    // GraphicBuffers of a defaultFormat if no format is specified
+    // in dequeueBuffer
+    status_t setDefaultBufferFormat(uint32_t defaultFormat);
+
+    // setDefaultBufferDataSpace allows the BufferQueue to create
+    // GraphicBuffers of a defaultDataSpace if no data space is specified
+    // in queueBuffer.
+    // The initial default is HAL_DATASPACE_UNKNOWN
+    status_t setDefaultBufferDataSpace(android_dataspace defaultDataSpace);
+
 };
 
 } // namespace android
diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index 09300a2..6c46203 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -17,25 +17,61 @@
 #ifndef ANDROID_GUI_BUFFERQUEUE_H
 #define ANDROID_GUI_BUFFERQUEUE_H
 
-#include <gui/BufferItem.h>
-#include <gui/BufferQueueDefs.h>
-#include <gui/IGraphicBufferConsumer.h>
-#include <gui/IGraphicBufferProducer.h>
+#include <gui/BufferQueueProducer.h>
+#include <gui/BufferQueueConsumer.h>
 #include <gui/IConsumerListener.h>
 
 // These are only required to keep other parts of the framework with incomplete
 // dependencies building successfully
 #include <gui/IGraphicBufferAlloc.h>
 
+#include <binder/IBinder.h>
+
 namespace android {
 
-class BufferQueue {
+// BQProducer and BQConsumer are thin shim classes to allow methods with the
+// same signature in both IGraphicBufferProducer and IGraphicBufferConsumer.
+// This will stop being an issue when we deprecate creating BufferQueues
+// directly (as opposed to using the *Producer and *Consumer interfaces).
+class BQProducer : public BnGraphicBufferProducer {
+public:
+    virtual status_t detachProducerBuffer(int slot) = 0;
+    virtual status_t attachProducerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer) = 0;
+
+    virtual status_t detachBuffer(int slot) {
+        return detachProducerBuffer(slot);
+    }
+
+    virtual status_t attachBuffer(int* slot, const sp<GraphicBuffer>& buffer) {
+        return attachProducerBuffer(slot, buffer);
+    }
+};
+
+class BQConsumer : public BnGraphicBufferConsumer {
+public:
+    virtual status_t detachConsumerBuffer(int slot) = 0;
+    virtual status_t attachConsumerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer) = 0;
+
+    virtual status_t detachBuffer(int slot) {
+        return detachConsumerBuffer(slot);
+    }
+
+    virtual status_t attachBuffer(int* slot, const sp<GraphicBuffer>& buffer) {
+        return attachConsumerBuffer(slot, buffer);
+    }
+};
+
+class BufferQueue : public BQProducer,
+                    public BQConsumer,
+                    private IBinder::DeathRecipient {
 public:
     // BufferQueue will keep track of at most this value of buffers.
     // Attempts at runtime to increase the number of buffers past this will fail.
     enum { NUM_BUFFER_SLOTS = BufferQueueDefs::NUM_BUFFER_SLOTS };
     // Used as a placeholder slot# when the value isn't pointing to an existing buffer.
-    enum { INVALID_BUFFER_SLOT = BufferItem::INVALID_BUFFER_SLOT };
+    enum { INVALID_BUFFER_SLOT = IGraphicBufferConsumer::BufferItem::INVALID_BUFFER_SLOT };
     // Alias to <IGraphicBufferConsumer.h> -- please scope from there in future code!
     enum {
         NO_BUFFER_AVAILABLE = IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
@@ -62,10 +98,9 @@ public:
     public:
         ProxyConsumerListener(const wp<ConsumerListener>& consumerListener);
         virtual ~ProxyConsumerListener();
-        virtual void onFrameAvailable(const BufferItem& item) override;
-        virtual void onFrameReplaced(const BufferItem& item) override;
-        virtual void onBuffersReleased() override;
-        virtual void onSidebandStreamChanged() override;
+        virtual void onFrameAvailable(const android::BufferItem& item);
+        virtual void onBuffersReleased();
+        virtual void onSidebandStreamChanged();
     private:
         // mConsumerListener is a weak reference to the IConsumerListener.  This is
         // the raison d'etre of ProxyConsumerListener.
@@ -75,12 +110,272 @@ public:
     // BufferQueue manages a pool of gralloc memory slots to be used by
     // producers and consumers. allocator is used to allocate all the
     // needed gralloc buffers.
+    BufferQueue(const sp<IGraphicBufferAlloc>& allocator = NULL);
+
     static void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
             sp<IGraphicBufferConsumer>* outConsumer,
             const sp<IGraphicBufferAlloc>& allocator = NULL);
 
+    virtual ~BufferQueue();
+
+    /*
+     * IBinder::DeathRecipient interface
+     */
+
+    virtual void binderDied(const wp<IBinder>& who);
+
+    /*
+     * IGraphicBufferProducer interface
+     */
+
+    // Query native window attributes.  The "what" values are enumerated in
+    // window.h (e.g. NATIVE_WINDOW_FORMAT).
+    virtual int query(int what, int* value);
+
+    // setBufferCount updates the number of available buffer slots.  If this
+    // method succeeds, buffer slots will be both unallocated and owned by
+    // the BufferQueue object (i.e. they are not owned by the producer or
+    // consumer).
+    //
+    // This will fail if the producer has dequeued any buffers, or if
+    // bufferCount is invalid.  bufferCount must generally be a value
+    // between the minimum undequeued buffer count (exclusive) and NUM_BUFFER_SLOTS
+    // (inclusive).  It may also be set to zero (the default) to indicate
+    // that the producer does not wish to set a value.  The minimum value
+    // can be obtained by calling query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
+    // ...).
+    //
+    // This may only be called by the producer.  The consumer will be told
+    // to discard buffers through the onBuffersReleased callback.
+    virtual status_t setBufferCount(int bufferCount);
+
+    // requestBuffer returns the GraphicBuffer for slot N.
+    //
+    // In normal operation, this is called the first time slot N is returned
+    // by dequeueBuffer.  It must be called again if dequeueBuffer returns
+    // flags indicating that previously-returned buffers are no longer valid.
+    virtual status_t requestBuffer(int slot, sp<GraphicBuffer>* buf);
+
+    // dequeueBuffer gets the next buffer slot index for the producer to use.
+    // If a buffer slot is available then that slot index is written to the
+    // location pointed to by the buf argument and a status of OK is returned.
+    // If no slot is available then a status of -EBUSY is returned and buf is
+    // unmodified.
+    //
+    // The fence parameter will be updated to hold the fence associated with
+    // the buffer. The contents of the buffer must not be overwritten until the
+    // fence signals. If the fence is Fence::NO_FENCE, the buffer may be
+    // written immediately.
+    //
+    // The width and height parameters must be no greater than the minimum of
+    // GL_MAX_VIEWPORT_DIMS and GL_MAX_TEXTURE_SIZE (see: glGetIntegerv).
+    // An error due to invalid dimensions might not be reported until
+    // updateTexImage() is called.  If width and height are both zero, the
+    // default values specified by setDefaultBufferSize() are used instead.
+    //
+    // The pixel formats are enumerated in graphics.h, e.g.
+    // HAL_PIXEL_FORMAT_RGBA_8888.  If the format is 0, the default format
+    // will be used.
+    //
+    // The usage argument specifies gralloc buffer usage flags.  The values
+    // are enumerated in gralloc.h, e.g. GRALLOC_USAGE_HW_RENDER.  These
+    // will be merged with the usage flags specified by setConsumerUsageBits.
+    //
+    // The return value may be a negative error value or a non-negative
+    // collection of flags.  If the flags are set, the return values are
+    // valid, but additional actions must be performed.
+    //
+    // If IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION is set, the
+    // producer must discard cached GraphicBuffer references for the slot
+    // returned in buf.
+    // If IGraphicBufferProducer::RELEASE_ALL_BUFFERS is set, the producer
+    // must discard cached GraphicBuffer references for all slots.
+    //
+    // In both cases, the producer will need to call requestBuffer to get a
+    // GraphicBuffer handle for the returned slot.
+    virtual status_t dequeueBuffer(int *buf, sp<Fence>* fence, bool async,
+            uint32_t width, uint32_t height, uint32_t format, uint32_t usage);
+
+    // See IGraphicBufferProducer::detachBuffer
+    virtual status_t detachProducerBuffer(int slot);
+
+    // See IGraphicBufferProducer::detachNextBuffer
+    virtual status_t detachNextBuffer(sp<GraphicBuffer>* outBuffer,
+            sp<Fence>* outFence);
+
+    // See IGraphicBufferProducer::attachBuffer
+    virtual status_t attachProducerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer);
+
+    // queueBuffer returns a filled buffer to the BufferQueue.
+    //
+    // Additional data is provided in the QueueBufferInput struct.  Notably,
+    // a timestamp must be provided for the buffer. The timestamp is in
+    // nanoseconds, and must be monotonically increasing. Its other semantics
+    // (zero point, etc) are producer-specific and should be documented by the
+    // producer.
+    //
+    // The caller may provide a fence that signals when all rendering
+    // operations have completed.  Alternatively, NO_FENCE may be used,
+    // indicating that the buffer is ready immediately.
+    //
+    // Some values are returned in the output struct: the current settings
+    // for default width and height, the current transform hint, and the
+    // number of queued buffers.
+    virtual status_t queueBuffer(int buf,
+            const QueueBufferInput& input, QueueBufferOutput* output);
+
+    // cancelBuffer returns a dequeued buffer to the BufferQueue, but doesn't
+    // queue it for use by the consumer.
+    //
+    // The buffer will not be overwritten until the fence signals.  The fence
+    // will usually be the one obtained from dequeueBuffer.
+    virtual void cancelBuffer(int buf, const sp<Fence>& fence);
+
+    // See IGraphicBufferProducer::connect
+    virtual status_t connect(const sp<IProducerListener>& listener,
+            int api, bool producerControlledByApp, QueueBufferOutput* output);
+
+    // disconnect attempts to disconnect a producer API from the BufferQueue.
+    // Calling this method will cause any subsequent calls to other
+    // IGraphicBufferProducer methods to fail except for getAllocator and connect.
+    // Successfully calling connect after this will allow the other methods to
+    // succeed again.
+    //
+    // This method will fail if the the BufferQueue is not currently
+    // connected to the specified producer API.
+    virtual status_t disconnect(int api);
+
+    // Attaches a sideband buffer stream to the BufferQueue.
+    //
+    // A sideband stream is a device-specific mechanism for passing buffers
+    // from the producer to the consumer without using dequeueBuffer/
+    // queueBuffer. If a sideband stream is present, the consumer can choose
+    // whether to acquire buffers from the sideband stream or from the queued
+    // buffers.
+    //
+    // Passing NULL or a different stream handle will detach the previous
+    // handle if any.
+    virtual status_t setSidebandStream(const sp<NativeHandle>& stream);
+
+    /*
+     * IGraphicBufferConsumer interface
+     */
+
+    // acquireBuffer attempts to acquire ownership of the next pending buffer in
+    // the BufferQueue.  If no buffer is pending then it returns NO_BUFFER_AVAILABLE. If a
+    // buffer is successfully acquired, the information about the buffer is
+    // returned in BufferItem.  If the buffer returned had previously been
+    // acquired then the BufferItem::mGraphicBuffer field of buffer is set to
+    // NULL and it is assumed that the consumer still holds a reference to the
+    // buffer.
+    //
+    // If presentWhen is nonzero, it indicates the time when the buffer will
+    // be displayed on screen.  If the buffer's timestamp is farther in the
+    // future, the buffer won't be acquired, and PRESENT_LATER will be
+    // returned.  The presentation time is in nanoseconds, and the time base
+    // is CLOCK_MONOTONIC.
+    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen);
+
+    // See IGraphicBufferConsumer::detachBuffer
+    virtual status_t detachConsumerBuffer(int slot);
+
+    // See IGraphicBufferConsumer::attachBuffer
+    virtual status_t attachConsumerBuffer(int* slot,
+            const sp<GraphicBuffer>& buffer);
+
+    // releaseBuffer releases a buffer slot from the consumer back to the
+    // BufferQueue.  This may be done while the buffer's contents are still
+    // being accessed.  The fence will signal when the buffer is no longer
+    // in use. frameNumber is used to indentify the exact buffer returned.
+    //
+    // If releaseBuffer returns STALE_BUFFER_SLOT, then the consumer must free
+    // any references to the just-released buffer that it might have, as if it
+    // had received a onBuffersReleased() call with a mask set for the released
+    // buffer.
+    //
+    // Note that the dependencies on EGL will be removed once we switch to using
+    // the Android HW Sync HAL.
+    virtual status_t releaseBuffer(int buf, uint64_t frameNumber,
+            EGLDisplay display, EGLSyncKHR fence,
+            const sp<Fence>& releaseFence);
+
+    // consumerConnect connects a consumer to the BufferQueue.  Only one
+    // consumer may be connected, and when that consumer disconnects the
+    // BufferQueue is placed into the "abandoned" state, causing most
+    // interactions with the BufferQueue by the producer to fail.
+    // controlledByApp indicates whether the consumer is controlled by
+    // the application.
+    //
+    // consumer may not be NULL.
+    virtual status_t consumerConnect(const sp<IConsumerListener>& consumer, bool controlledByApp);
+
+    // consumerDisconnect disconnects a consumer from the BufferQueue. All
+    // buffers will be freed and the BufferQueue is placed in the "abandoned"
+    // state, causing most interactions with the BufferQueue by the producer to
+    // fail.
+    virtual status_t consumerDisconnect();
+
+    // getReleasedBuffers sets the value pointed to by slotMask to a bit mask
+    // indicating which buffer slots have been released by the BufferQueue
+    // but have not yet been released by the consumer.
+    //
+    // This should be called from the onBuffersReleased() callback.
+    virtual status_t getReleasedBuffers(uint64_t* slotMask);
+
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // dequeueBuffer when a width and height of zero is requested.  Default
+    // is 1x1.
+    virtual status_t setDefaultBufferSize(uint32_t w, uint32_t h);
+
+    // setDefaultMaxBufferCount sets the default value for the maximum buffer
+    // count (the initial default is 2). If the producer has requested a
+    // buffer count using setBufferCount, the default buffer count will only
+    // take effect if the producer sets the count back to zero.
+    //
+    // The count must be between 2 and NUM_BUFFER_SLOTS, inclusive.
+    virtual status_t setDefaultMaxBufferCount(int bufferCount);
+
+    // disableAsyncBuffer disables the extra buffer used in async mode
+    // (when both producer and consumer have set their "isControlledByApp"
+    // flag) and has dequeueBuffer() return WOULD_BLOCK instead.
+    //
+    // This can only be called before consumerConnect().
+    virtual status_t disableAsyncBuffer();
+
+    // setMaxAcquiredBufferCount sets the maximum number of buffers that can
+    // be acquired by the consumer at one time (default 1).  This call will
+    // fail if a producer is connected to the BufferQueue.
+    virtual status_t setMaxAcquiredBufferCount(int maxAcquiredBuffers);
+
+    // setConsumerName sets the name used in logging
+    virtual void setConsumerName(const String8& name);
+
+    // setDefaultBufferFormat allows the BufferQueue to create
+    // GraphicBuffers of a defaultFormat if no format is specified
+    // in dequeueBuffer.  Formats are enumerated in graphics.h; the
+    // initial default is HAL_PIXEL_FORMAT_RGBA_8888.
+    virtual status_t setDefaultBufferFormat(uint32_t defaultFormat);
+
+    // setConsumerUsageBits will turn on additional usage bits for dequeueBuffer.
+    // These are merged with the bits passed to dequeueBuffer.  The values are
+    // enumerated in gralloc.h, e.g. GRALLOC_USAGE_HW_RENDER; the default is 0.
+    virtual status_t setConsumerUsageBits(uint32_t usage);
+
+    // setTransformHint bakes in rotation to buffers so overlays can be used.
+    // The values are enumerated in window.h, e.g.
+    // NATIVE_WINDOW_TRANSFORM_ROT_90.  The default is 0 (no transform).
+    virtual status_t setTransformHint(uint32_t hint);
+
+    // Retrieve the BufferQueue's sideband stream, if any.
+    virtual sp<NativeHandle> getSidebandStream() const;
+
+    // dump our state in a String
+    virtual void dump(String8& result, const char* prefix) const;
+
 private:
-    BufferQueue(); // Create through createBufferQueue
+    sp<BufferQueueProducer> mProducer;
+    sp<BufferQueueConsumer> mConsumer;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/BufferQueueConsumer.h b/include/gui/BufferQueueConsumer.h
index cde302f..9c91fc7 100644
--- a/include/gui/BufferQueueConsumer.h
+++ b/include/gui/BufferQueueConsumer.h
@@ -47,7 +47,7 @@ public:
     // returned.  The presentation time is in nanoseconds, and the time base
     // is CLOCK_MONOTONIC.
     virtual status_t acquireBuffer(BufferItem* outBuffer,
-            nsecs_t expectedPresent, uint64_t maxFrameNumber = 0) override;
+            nsecs_t expectedPresent);
 
     // See IGraphicBufferConsumer::detachBuffer
     virtual status_t detachBuffer(int slot);
diff --git a/include/gui/BufferQueueCore.h b/include/gui/BufferQueueCore.h
index 99134ea..4c2c31a 100644
--- a/include/gui/BufferQueueCore.h
+++ b/include/gui/BufferQueueCore.h
@@ -17,7 +17,6 @@
 #ifndef ANDROID_GUI_BUFFERQUEUECORE_H
 #define ANDROID_GUI_BUFFERQUEUECORE_H
 
-#include <gui/BufferItem.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/BufferSlot.h>
 
@@ -49,6 +48,7 @@
 
 namespace android {
 
+class BufferItem;
 class IConsumerListener;
 class IGraphicBufferAlloc;
 class IProducerListener;
@@ -61,7 +61,7 @@ class BufferQueueCore : public virtual RefBase {
 public:
     // Used as a placeholder slot number when the value isn't pointing to an
     // existing buffer.
-    enum { INVALID_BUFFER_SLOT = BufferItem::INVALID_BUFFER_SLOT };
+    enum { INVALID_BUFFER_SLOT = -1 }; // TODO: Extract from IGBC::BufferItem
 
     // We reserve two slots in order to guarantee that the producer and
     // consumer can run asynchronously.
diff --git a/include/gui/BufferQueueProducer.h b/include/gui/BufferQueueProducer.h
index 9754a89..65ce96a 100644
--- a/include/gui/BufferQueueProducer.h
+++ b/include/gui/BufferQueueProducer.h
@@ -19,6 +19,7 @@
 
 #include <gui/BufferQueueDefs.h>
 #include <gui/IGraphicBufferProducer.h>
+#include <utils/Condition.h>
 
 namespace android {
 
diff --git a/include/gui/ConsumerBase.h b/include/gui/ConsumerBase.h
index 9307a26..ac102f5 100644
--- a/include/gui/ConsumerBase.h
+++ b/include/gui/ConsumerBase.h
@@ -38,9 +38,15 @@ class ConsumerBase : public virtual RefBase,
         protected ConsumerListener {
 public:
     struct FrameAvailableListener : public virtual RefBase {
-        // See IConsumerListener::onFrame{Available,Replaced}
+        // onFrameAvailable() is called each time an additional frame becomes
+        // available for consumption. This means that frames that are queued
+        // while in asynchronous mode only trigger the callback if no previous
+        // frames are pending. Frames queued while in synchronous mode always
+        // trigger the callback.
+        //
+        // This is called without any lock held and can be called concurrently
+        // by multiple threads.
         virtual void onFrameAvailable(const BufferItem& item) = 0;
-        virtual void onFrameReplaced(const BufferItem& /* item */) {}
     };
 
     virtual ~ConsumerBase();
@@ -110,16 +116,14 @@ protected:
 
     // Implementation of the IConsumerListener interface.  These
     // calls are used to notify the ConsumerBase of asynchronous events in the
-    // BufferQueue.  The onFrameAvailable, onFrameReplaced, and
-    // onBuffersReleased methods should not need to be overridden by derived
-    // classes, but if they are overridden the ConsumerBase implementation must
-    // be called from the derived class. The ConsumerBase version of
-    // onSidebandStreamChanged does nothing and can be overriden by derived
-    // classes if they want the notification.
-    virtual void onFrameAvailable(const BufferItem& item) override;
-    virtual void onFrameReplaced(const BufferItem& item) override;
-    virtual void onBuffersReleased() override;
-    virtual void onSidebandStreamChanged() override;
+    // BufferQueue.  The onFrameAvailable and onBuffersReleased methods should
+    // not need to be overridden by derived classes, but if they are overridden
+    // the ConsumerBase implementation must be called from the derived class.
+    // The ConsumerBase version of onSidebandStreamChanged does nothing and can
+    // be overriden by derived classes if they want the notification.
+    virtual void onFrameAvailable(const BufferItem& item);
+    virtual void onBuffersReleased();
+    virtual void onSidebandStreamChanged();
 
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
@@ -164,8 +168,7 @@ protected:
     // initialization that must take place the first time a buffer is assigned
     // to a slot.  If it is overridden the derived class's implementation must
     // call ConsumerBase::acquireBufferLocked.
-    virtual status_t acquireBufferLocked(BufferItem *item, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0);
+    virtual status_t acquireBufferLocked(IGraphicBufferConsumer::BufferItem *item, nsecs_t presentWhen);
 
     // releaseBufferLocked relinquishes control over a buffer, returning that
     // control to the BufferQueue.
diff --git a/include/gui/CpuConsumer.h b/include/gui/CpuConsumer.h
index 3b07a31..c99ab29 100644
--- a/include/gui/CpuConsumer.h
+++ b/include/gui/CpuConsumer.h
@@ -80,6 +80,23 @@ class CpuConsumer : public ConsumerBase
     // log messages.
     void setName(const String8& name);
 
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // requestBuffers when a width and height of zero is requested.
+    // A call to setDefaultBufferSize() may trigger requestBuffers() to
+    // be called from the client. Default size is 1x1.
+    status_t setDefaultBufferSize(uint32_t width, uint32_t height);
+
+    // setDefaultBufferFormat allows CpuConsumer's BufferQueue to create buffers
+    // of a defaultFormat if no format is specified by producer.
+    // The initial default is PIXEL_FORMAT_RGBA_8888.
+    status_t setDefaultBufferFormat(PixelFormat defaultFormat);
+
+    // setDefaultBufferDataSpace allows the BufferQueue to create
+    // GraphicBuffers of a defaultDataSpace if no data space is specified
+    // in queueBuffer.
+    // The initial default is HAL_DATASPACE_UNKNOWN
+    status_t setDefaultBufferDataSpace(android_dataspace defaultDataSpace);
+
     // Gets the next graphics buffer from the producer and locks it for CPU use,
     // filling out the passed-in locked buffer structure with the native pointer
     // and metadata. Returns BAD_VALUE if no new buffer is available, and
diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index c35c7be..3949e28 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -241,8 +241,7 @@ protected:
 
     // acquireBufferLocked overrides the ConsumerBase method to update the
     // mEglSlots array in addition to the ConsumerBase behavior.
-    virtual status_t acquireBufferLocked(BufferItem *item, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0) override;
+    virtual status_t acquireBufferLocked(BufferQueue::BufferItem *item, nsecs_t presentWhen);
 
     // releaseBufferLocked overrides the ConsumerBase method to update the
     // mEglSlots array in addition to the ConsumerBase.
@@ -260,7 +259,7 @@ protected:
     // This releases the buffer in the slot referenced by mCurrentTexture,
     // then updates state to refer to the BufferItem, which must be a
     // newly-acquired buffer.
-    status_t updateAndReleaseLocked(const BufferItem& item);
+    status_t updateAndReleaseLocked(const BufferQueue::BufferItem& item);
 
     // Binds mTexName and the current buffer to mTexTarget.  Uses
     // mCurrentTexture if it's set, mCurrentTextureImage if not.  If the
diff --git a/include/gui/IGraphicBufferConsumer.h b/include/gui/IGraphicBufferConsumer.h
index 60ec9cc..42e491f 100644
--- a/include/gui/IGraphicBufferConsumer.h
+++ b/include/gui/IGraphicBufferConsumer.h
@@ -34,7 +34,6 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
-class BufferItem;
 class Fence;
 class GraphicBuffer;
 class IConsumerListener;
@@ -43,6 +42,75 @@ class NativeHandle;
 class IGraphicBufferConsumer : public IInterface {
 
 public:
+
+    // public facing structure for BufferSlot
+    class BufferItem : public Flattenable<BufferItem> {
+        friend class Flattenable<BufferItem>;
+        size_t getPodSize() const;
+        size_t getFlattenedSize() const;
+        size_t getFdCount() const;
+        status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const;
+        status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count);
+
+    public:
+        // The default value of mBuf, used to indicate this doesn't correspond to a slot.
+        enum { INVALID_BUFFER_SLOT = -1 };
+        BufferItem();
+
+        // mGraphicBuffer points to the buffer allocated for this slot, or is NULL
+        // if the buffer in this slot has been acquired in the past (see
+        // BufferSlot.mAcquireCalled).
+        sp<GraphicBuffer> mGraphicBuffer;
+
+        // mFence is a fence that will signal when the buffer is idle.
+        sp<Fence> mFence;
+
+        // mCrop is the current crop rectangle for this buffer slot.
+        Rect mCrop;
+
+        // mTransform is the current transform flags for this buffer slot.
+        // refer to NATIVE_WINDOW_TRANSFORM_* in <window.h>
+        uint32_t mTransform;
+
+        // mScalingMode is the current scaling mode for this buffer slot.
+        // refer to NATIVE_WINDOW_SCALING_* in <window.h>
+        uint32_t mScalingMode;
+
+        // mTimestamp is the current timestamp for this buffer slot. This gets
+        // to set by queueBuffer each time this slot is queued. This value
+        // is guaranteed to be monotonically increasing for each newly
+        // acquired buffer.
+        int64_t mTimestamp;
+
+        // mIsAutoTimestamp indicates whether mTimestamp was generated
+        // automatically when the buffer was queued.
+        bool mIsAutoTimestamp;
+
+        // mDataSpace is the current dataSpace for this buffer slot. This gets
+        // set by queueBuffer each time this slot is queued.
+        android_dataspace mDataSpace;
+
+        // mFrameNumber is the number of the queued frame for this slot.
+        uint64_t mFrameNumber;
+
+        // mBuf is the slot index of this buffer (default INVALID_BUFFER_SLOT).
+        int mBuf;
+
+        // mIsDroppable whether this buffer was queued with the
+        // property that it can be replaced by a new buffer for the purpose of
+        // making sure dequeueBuffer() won't block.
+        // i.e.: was the BufferQueue in "mDequeueBufferCannotBlock" when this buffer
+        // was queued.
+        bool mIsDroppable;
+
+        // Indicates whether this buffer has been seen by a consumer yet
+        bool mAcquireCalled;
+
+        // Indicates this buffer must be transformed by the inverse transform of the screen
+        // it is displayed onto. This is applied after mTransform.
+        bool mTransformToDisplayInverse;
+    };
+
     enum {
         // Returned by releaseBuffer, after which the consumer must
         // free any references to the just-released buffer that it might have.
@@ -84,8 +152,7 @@ public:
     //
     // Return of a negative value means an error has occurred:
     // * INVALID_OPERATION - too many buffers have been acquired
-    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0) = 0;
+    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen) = 0;
 
     // detachBuffer attempts to remove all ownership of the buffer in the given
     // slot from the buffer queue. If this call succeeds, the slot will be
diff --git a/include/gui/SensorManager.h b/include/gui/SensorManager.h
index 0cff46c..f500776 100644
--- a/include/gui/SensorManager.h
+++ b/include/gui/SensorManager.h
@@ -56,7 +56,12 @@ public:
 
     ssize_t getSensorList(Sensor const* const** list) const;
     Sensor const* getDefaultSensor(int type);
+#ifdef MTK_HARDWARE
+    sp<SensorEventQueue> createEventQueue(String8 packageName, int mode = 0);
+    sp<SensorEventQueue> createEventQueue();
+#else
     sp<SensorEventQueue> createEventQueue(String8 packageName = String8(""), int mode = 0);
+#endif
     bool isDataInjectionEnabled();
 
 private:
@@ -64,6 +69,9 @@ private:
     void sensorManagerDied();
 
     SensorManager(const String16& opPackageName);
+#ifdef MTK_HARDWARE
+    SensorManager();
+#endif
     status_t assertStateLocked() const;
 
 private:
@@ -78,6 +86,15 @@ private:
     const String16 mOpPackageName;
 };
 
+
+#ifdef MTK_HARDWARE
+// be compatible with MTK Lollipop blobs
+extern "C" {
+    extern android::Mutex _ZN7android9SingletonINS_13SensorManagerEE5sLockE;
+    extern SensorManager *_ZN7android9SingletonINS_13SensorManagerEE9sInstanceE;
+}
+#endif  // MTK_HARDWARE
+
 // ----------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index b431bd5..befd640 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -110,6 +110,11 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+
+#ifdef MTK_HARDWARE
+private:
+    void dump(int fd);
+#endif
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 9900624..52eba1c 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -72,6 +72,15 @@ private:
     gralloc_module_t const *mAllocMod;
 };
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
+
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 0000000..8f9b663
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,49 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 0000000..8431544
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,63 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <utils/KeyedVector.h>
+#include <utils/Singleton.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android
+{
+class RefBaseMonitor;
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+class RefBaseDump : public BnDumpTunnel {
+
+public:
+    RefBaseDump(RefBaseMonitor*);
+    virtual ~RefBaseDump();
+
+    // IDumpTunnel interface
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
+
+private:
+    RefBaseMonitor *mMonitor;
+};
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public Singleton<RefBaseMonitor> {
+public:
+    RefBaseMonitor();
+    virtual ~RefBaseMonitor();
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* );
+
+    // remove refbase from the monitored list
+    status_t unmonitor(RefBase* );
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result);
+
+private:
+    status_t getProcessName();
+
+    // if trackMe needed
+    bool mIsTracking;
+
+    String8 mProcessName;
+
+    sp<RefBaseDump> mDump;
+
+    // the list where monitored refbase objects are saved
+    KeyedVector<RefBase*,int> RbList;
+
+    mutable Mutex mMutex;;
+};
+
+};
+#endif
diff --git a/libs/binder/Android.mk b/libs/binder/Android.mk
index b12eda8..1550fd0 100644
--- a/libs/binder/Android.mk
+++ b/libs/binder/Android.mk
@@ -37,6 +37,7 @@ sources := \
     ProcessState.cpp \
     Static.cpp \
     TextOutput.cpp \
+    MediatekHacks.cpp
 
 ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
 sources += \
diff --git a/libs/binder/MediatekHacks.cpp b/libs/binder/MediatekHacks.cpp
new file mode 100644
index 0000000..003b9b7
--- /dev/null
+++ b/libs/binder/MediatekHacks.cpp
@@ -0,0 +1,7 @@
+extern "C" {
+    void _ZN7android6Parcel13writeString16EPKDsj(char16_t const*, unsigned int);
+
+    void _ZN7android6Parcel13writeString16EPKtj(unsigned short const* str, unsigned int len){
+        _ZN7android6Parcel13writeString16EPKDsj((char16_t const*)str, len);
+    }
+}
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 76aec6e..2813207 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -70,6 +70,7 @@ LOCAL_SRC_FILES := \
 	SurfaceControl.cpp \
 	SurfaceComposerClient.cpp \
 	SyncFeatures.cpp \
+	MediatekHacks.cpp
 
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
diff --git a/libs/gui/BufferItem.cpp b/libs/gui/BufferItem.cpp
index 8f64ae0..6709e8b 100644
--- a/libs/gui/BufferItem.cpp
+++ b/libs/gui/BufferItem.cpp
@@ -37,30 +37,53 @@ BufferItem::BufferItem() :
     mCrop.makeInvalid();
 }
 
+BufferItem::BufferItem(const IGraphicBufferConsumer::BufferItem& item) :
+    mGraphicBuffer(item.mGraphicBuffer),
+    mFence(item.mFence),
+    mCrop(item.mCrop),
+    mTransform(item.mTransform),
+    mScalingMode(item.mScalingMode),
+    mTimestamp(item.mTimestamp),
+    mIsAutoTimestamp(item.mIsAutoTimestamp),
+    mDataSpace(item.mDataSpace),
+    mFrameNumber(item.mFrameNumber),
+    mSlot(item.mBuf),
+    mIsDroppable(item.mIsDroppable),
+    mAcquireCalled(item.mAcquireCalled),
+    mTransformToDisplayInverse(item.mTransformToDisplayInverse) {}
+
 BufferItem::~BufferItem() {}
 
-template <typename T>
-static void addAligned(size_t& size, T /* value */) {
-    size = FlattenableUtils::align<sizeof(T)>(size);
-    size += sizeof(T);
+BufferItem::operator IGraphicBufferConsumer::BufferItem() const {
+    IGraphicBufferConsumer::BufferItem bufferItem;
+    bufferItem.mGraphicBuffer = mGraphicBuffer;
+    bufferItem.mFence = mFence;
+    bufferItem.mCrop = mCrop;
+    bufferItem.mTransform = mTransform;
+    bufferItem.mScalingMode = mScalingMode;
+    bufferItem.mTimestamp = mTimestamp;
+    bufferItem.mIsAutoTimestamp = mIsAutoTimestamp;
+    bufferItem.mDataSpace = mDataSpace;
+    bufferItem.mFrameNumber = mFrameNumber;
+    bufferItem.mBuf = mSlot;
+    bufferItem.mIsDroppable = mIsDroppable;
+    bufferItem.mAcquireCalled = mAcquireCalled;
+    bufferItem.mTransformToDisplayInverse = mTransformToDisplayInverse;
+    return bufferItem;
 }
 
 size_t BufferItem::getPodSize() const {
-    size_t size = 0;
-    addAligned(size, mCrop);
-    addAligned(size, mTransform);
-    addAligned(size, mScalingMode);
-    addAligned(size, mTimestampLo);
-    addAligned(size, mTimestampHi);
-    addAligned(size, mIsAutoTimestamp);
-    addAligned(size, mDataSpace);
-    addAligned(size, mFrameNumberLo);
-    addAligned(size, mFrameNumberHi);
-    addAligned(size, mSlot);
-    addAligned(size, mIsDroppable);
-    addAligned(size, mAcquireCalled);
-    addAligned(size, mTransformToDisplayInverse);
-    return size;
+    size_t c =  sizeof(mCrop) +
+            sizeof(mTransform) +
+            sizeof(mScalingMode) +
+            sizeof(mTimestamp) +
+            sizeof(mIsAutoTimestamp) +
+            sizeof(mFrameNumber) +
+            sizeof(mSlot) +
+            sizeof(mIsDroppable) +
+            sizeof(mAcquireCalled) +
+            sizeof(mTransformToDisplayInverse);
+    return c;
 }
 
 size_t BufferItem::getFlattenedSize() const {
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index 578b8d9..6c4717e 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -53,7 +53,7 @@ void BufferItemConsumer::setName(const String8& name) {
     mConsumer->setConsumerName(name);
 }
 
-status_t BufferItemConsumer::acquireBuffer(BufferItem *item,
+status_t BufferItemConsumer::acquireBuffer(BufferQueue::BufferItem *item,
         nsecs_t presentWhen, bool waitForFence) {
     status_t err;
 
@@ -83,6 +83,17 @@ status_t BufferItemConsumer::acquireBuffer(BufferItem *item,
     return OK;
 }
 
+status_t BufferItemConsumer::acquireBuffer(android::BufferItem* outItem,
+        nsecs_t presentWhen, bool waitForFence) {
+    BufferQueue::BufferItem item;
+    status_t result = acquireBuffer(&item, presentWhen, waitForFence);
+    if (result != NO_ERROR) {
+        return result;
+    }
+    *outItem = item;
+    return NO_ERROR;
+}
+
 status_t BufferItemConsumer::releaseBuffer(const BufferItem &item,
         const sp<Fence>& releaseFence) {
     status_t err;
@@ -100,4 +111,17 @@ status_t BufferItemConsumer::releaseBuffer(const BufferItem &item,
     return err;
 }
 
+status_t BufferItemConsumer::setDefaultBufferSize(uint32_t w, uint32_t h) {
+	return ConsumerBase::setDefaultBufferSize(w, h);
+}
+
+status_t BufferItemConsumer::setDefaultBufferFormat(uint32_t defaultFormat) {
+    return ConsumerBase::setDefaultBufferFormat(static_cast<PixelFormat>(defaultFormat));
+}
+
+status_t BufferItemConsumer::setDefaultBufferDataSpace(
+        android_dataspace defaultDataSpace) {
+    return ConsumerBase::setDefaultBufferDataSpace(defaultDataSpace);
+}
+
 } // namespace android
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index ccbb5a2..8af6730 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -19,9 +19,7 @@
 //#define LOG_NDEBUG 0
 
 #include <gui/BufferQueue.h>
-#include <gui/BufferQueueConsumer.h>
 #include <gui/BufferQueueCore.h>
-#include <gui/BufferQueueProducer.h>
 
 namespace android {
 
@@ -32,21 +30,13 @@ BufferQueue::ProxyConsumerListener::ProxyConsumerListener(
 BufferQueue::ProxyConsumerListener::~ProxyConsumerListener() {}
 
 void BufferQueue::ProxyConsumerListener::onFrameAvailable(
-        const BufferItem& item) {
+        const android::BufferItem& item) {
     sp<ConsumerListener> listener(mConsumerListener.promote());
     if (listener != NULL) {
         listener->onFrameAvailable(item);
     }
 }
 
-void BufferQueue::ProxyConsumerListener::onFrameReplaced(
-        const BufferItem& item) {
-    sp<ConsumerListener> listener(mConsumerListener.promote());
-    if (listener != NULL) {
-        listener->onFrameReplaced(item);
-    }
-}
-
 void BufferQueue::ProxyConsumerListener::onBuffersReleased() {
     sp<ConsumerListener> listener(mConsumerListener.promote());
     if (listener != NULL) {
@@ -54,13 +44,6 @@ void BufferQueue::ProxyConsumerListener::onBuffersReleased() {
     }
 }
 
-void BufferQueue::ProxyConsumerListener::onSidebandStreamChanged() {
-    sp<ConsumerListener> listener(mConsumerListener.promote());
-    if (listener != NULL) {
-        listener->onSidebandStreamChanged();
-    }
-}
-
 void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
         sp<IGraphicBufferConsumer>* outConsumer,
         const sp<IGraphicBufferAlloc>& allocator) {
@@ -85,4 +68,151 @@ void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
     *outConsumer = consumer;
 }
 
+BufferQueue::BufferQueue(const sp<IGraphicBufferAlloc>& allocator) :
+    mProducer(),
+    mConsumer()
+{
+    sp<BufferQueueCore> core(new BufferQueueCore(allocator));
+    mProducer = new BufferQueueProducer(core);
+    mConsumer = new BufferQueueConsumer(core);
+}
+
+BufferQueue::~BufferQueue() {}
+
+void BufferQueue::binderDied(const wp<IBinder>& who) {
+    mProducer->binderDied(who);
+}
+
+int BufferQueue::query(int what, int* outValue) {
+    return mProducer->query(what, outValue);
+}
+
+status_t BufferQueue::setBufferCount(int bufferCount) {
+    return mProducer->setBufferCount(bufferCount);
+}
+
+status_t BufferQueue::requestBuffer(int slot, sp<GraphicBuffer>* buf) {
+    return mProducer->requestBuffer(slot, buf);
+}
+
+status_t BufferQueue::dequeueBuffer(int *outBuf, sp<Fence>* outFence, bool async,
+        uint32_t w, uint32_t h, uint32_t format, uint32_t usage) {
+    return mProducer->dequeueBuffer(outBuf, outFence, async, w, h, static_cast<PixelFormat>(format), usage);
+}
+
+status_t BufferQueue::detachProducerBuffer(int slot) {
+    return mProducer->detachBuffer(slot);
+}
+
+status_t BufferQueue::detachNextBuffer(sp<GraphicBuffer>* outBuffer,
+        sp<Fence>* outFence) {
+    return mProducer->detachNextBuffer(outBuffer, outFence);
+}
+
+status_t BufferQueue::attachProducerBuffer(int* slot,
+        const sp<GraphicBuffer>& buffer) {
+    return mProducer->attachBuffer(slot, buffer);
+}
+
+status_t BufferQueue::queueBuffer(int buf,
+        const QueueBufferInput& input, QueueBufferOutput* output) {
+    return mProducer->queueBuffer(buf, input, output);
+}
+
+void BufferQueue::cancelBuffer(int buf, const sp<Fence>& fence) {
+    mProducer->cancelBuffer(buf, fence);
+}
+
+status_t BufferQueue::connect(const sp<IProducerListener>& listener,
+        int api, bool producerControlledByApp, QueueBufferOutput* output) {
+    return mProducer->connect(listener, api, producerControlledByApp, output);
+}
+
+status_t BufferQueue::disconnect(int api) {
+    return mProducer->disconnect(api);
+}
+
+status_t BufferQueue::setSidebandStream(const sp<NativeHandle>& stream) {
+    return mProducer->setSidebandStream(stream);
+}
+
+status_t BufferQueue::acquireBuffer(BufferItem* buffer, nsecs_t presentWhen) {
+    return mConsumer->acquireBuffer(buffer, presentWhen);
+}
+
+status_t BufferQueue::detachConsumerBuffer(int slot) {
+    return mConsumer->detachBuffer(slot);
+}
+
+status_t BufferQueue::attachConsumerBuffer(int* slot,
+        const sp<GraphicBuffer>& buffer) {
+    return mConsumer->attachBuffer(slot, buffer);
+}
+
+status_t BufferQueue::releaseBuffer(
+        int buf, uint64_t frameNumber, EGLDisplay display,
+        EGLSyncKHR eglFence, const sp<Fence>& fence) {
+    return mConsumer->releaseBuffer(buf, frameNumber, fence, display, eglFence);
+}
+
+status_t BufferQueue::consumerConnect(const sp<IConsumerListener>& consumerListener,
+        bool controlledByApp) {
+    return mConsumer->connect(consumerListener, controlledByApp);
+}
+
+status_t BufferQueue::consumerDisconnect() {
+    return mConsumer->disconnect();
+}
+
+status_t BufferQueue::getReleasedBuffers(uint64_t* slotMask) {
+    return mConsumer->getReleasedBuffers(slotMask);
+}
+
+status_t BufferQueue::setDefaultBufferSize(uint32_t w, uint32_t h) {
+    return mConsumer->setDefaultBufferSize(w, h);
+}
+
+status_t BufferQueue::setDefaultMaxBufferCount(int bufferCount) {
+    return mConsumer->setDefaultMaxBufferCount(bufferCount);
+}
+
+status_t BufferQueue::disableAsyncBuffer() {
+    return mConsumer->disableAsyncBuffer();
+}
+
+status_t BufferQueue::setMaxAcquiredBufferCount(int maxAcquiredBuffers) {
+    return mConsumer->setMaxAcquiredBufferCount(maxAcquiredBuffers);
+}
+
+void BufferQueue::setConsumerName(const String8& name) {
+    mConsumer->setConsumerName(name);
+}
+
+status_t BufferQueue::setDefaultBufferFormat(uint32_t defaultFormat) {
+    return mConsumer->setDefaultBufferFormat(static_cast<PixelFormat>(defaultFormat));
+}
+
+status_t BufferQueue::setConsumerUsageBits(uint32_t usage) {
+    return mConsumer->setConsumerUsageBits(usage);
+}
+
+status_t BufferQueue::setTransformHint(uint32_t hint) {
+    return mConsumer->setTransformHint(hint);
+}
+
+sp<NativeHandle> BufferQueue::getSidebandStream() const {
+    return mConsumer->getSidebandStream();
+}
+
+void BufferQueue::dump(String8& result, const char* prefix) const {
+    mConsumer->dump(result, prefix);
+}
+
+void BufferQueue::ProxyConsumerListener::onSidebandStreamChanged() {
+    sp<ConsumerListener> listener(mConsumerListener.promote());
+    if (listener != NULL) {
+        listener->onSidebandStreamChanged();
+    }
+}
+
 }; // namespace android
diff --git a/libs/gui/BufferQueueConsumer.cpp b/libs/gui/BufferQueueConsumer.cpp
index 7504ed4..1ff4700 100644
--- a/libs/gui/BufferQueueConsumer.cpp
+++ b/libs/gui/BufferQueueConsumer.cpp
@@ -40,7 +40,7 @@ BufferQueueConsumer::BufferQueueConsumer(const sp<BufferQueueCore>& core) :
 BufferQueueConsumer::~BufferQueueConsumer() {}
 
 status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
-        nsecs_t expectedPresent, uint64_t maxFrameNumber) {
+        nsecs_t expectedPresent) {
     ATRACE_CALL();
 
     int numDroppedBuffers = 0;
@@ -100,12 +100,6 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
             while (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
                 const BufferItem& bufferItem(mCore->mQueue[1]);
 
-                // If dropping entry[0] would leave us with a buffer that the
-                // consumer is not yet ready for, don't drop it.
-                if (maxFrameNumber && bufferItem.mFrameNumber > maxFrameNumber) {
-                    break;
-                }
-
                 // If entry[1] is timely, drop entry[0] (and repeat). We apply an
                 // additional criterion here: we only drop the earlier buffer if our
                 // desiredPresent falls within +/- 1 second of the expected present.
@@ -147,16 +141,12 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
             nsecs_t desiredPresent = front->mTimestamp;
             bool bufferIsDue = desiredPresent <= expectedPresent ||
                     desiredPresent > expectedPresent + MAX_REASONABLE_NSEC;
-            bool consumerIsReady = maxFrameNumber > 0 ?
-                    front->mFrameNumber <= maxFrameNumber : true;
-            if (!bufferIsDue || !consumerIsReady) {
+            if (!bufferIsDue) {
                 BQ_LOGV("acquireBuffer: defer desire=%" PRId64 " expect=%" PRId64
-                        " (%" PRId64 ") now=%" PRId64 " frame=%" PRIu64
-                        " consumer=%" PRIu64,
+                        " (%" PRId64 ") now=%" PRId64,
                         desiredPresent, expectedPresent,
                         desiredPresent - expectedPresent,
-                        systemTime(CLOCK_MONOTONIC),
-                        front->mFrameNumber, maxFrameNumber);
+                        systemTime(CLOCK_MONOTONIC));
                 return PRESENT_LATER;
             }
 
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 04ab06b..0b655d9 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -114,21 +114,6 @@ void ConsumerBase::onFrameAvailable(const BufferItem& item) {
     }
 }
 
-void ConsumerBase::onFrameReplaced(const BufferItem &item) {
-    CB_LOGV("onFrameReplaced");
-
-    sp<FrameAvailableListener> listener;
-    {
-        Mutex::Autolock lock(mMutex);
-        listener = mFrameAvailableListener.promote();
-    }
-
-    if (listener != NULL) {
-        CB_LOGV("actually calling onFrameReplaced");
-        listener->onFrameReplaced(item);
-    }
-}
-
 void ConsumerBase::onBuffersReleased() {
     Mutex::Autolock lock(mMutex);
 
@@ -231,9 +216,9 @@ void ConsumerBase::dumpLocked(String8& result, const char* prefix) const {
     }
 }
 
-status_t ConsumerBase::acquireBufferLocked(BufferItem *item,
-        nsecs_t presentWhen, uint64_t maxFrameNumber) {
-    status_t err = mConsumer->acquireBuffer(item, presentWhen, maxFrameNumber);
+status_t ConsumerBase::acquireBufferLocked(BufferQueue::BufferItem *item,
+        nsecs_t presentWhen) {
+    status_t err = mConsumer->acquireBuffer(item, presentWhen);
     if (err != NO_ERROR) {
         return err;
     }
diff --git a/libs/gui/CpuConsumer.cpp b/libs/gui/CpuConsumer.cpp
index e29b740..03ee4d7 100644
--- a/libs/gui/CpuConsumer.cpp
+++ b/libs/gui/CpuConsumer.cpp
@@ -56,6 +56,22 @@ void CpuConsumer::setName(const String8& name) {
     mConsumer->setConsumerName(name);
 }
 
+status_t CpuConsumer::setDefaultBufferSize(uint32_t width, uint32_t height)
+{
+    return ConsumerBase::setDefaultBufferSize(width, height);
+}
+
+status_t CpuConsumer::setDefaultBufferFormat(PixelFormat defaultFormat)
+{
+    return ConsumerBase::setDefaultBufferFormat(defaultFormat);
+}
+
+status_t CpuConsumer::setDefaultBufferDataSpace(
+        android_dataspace defaultDataSpace)
+{
+    return ConsumerBase::setDefaultBufferDataSpace(defaultDataSpace);
+}
+
 static bool isPossiblyYUV(PixelFormat format) {
     switch (static_cast<int>(format)) {
         case HAL_PIXEL_FORMAT_RGBA_8888:
@@ -92,7 +108,7 @@ status_t CpuConsumer::lockNextBuffer(LockedBuffer *nativeBuffer) {
         return NOT_ENOUGH_DATA;
     }
 
-    BufferItem b;
+    BufferQueue::BufferItem b;
 
     Mutex::Autolock _l(mMutex);
 
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 757e08a..39b450c 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -211,7 +211,7 @@ status_t GLConsumer::updateTexImage() {
         return err;
     }
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     // Acquire the next buffer.
     // In asynchronous mode the list is guaranteed to be one buffer
@@ -343,10 +343,9 @@ sp<GraphicBuffer> GLConsumer::getDebugTexImageBuffer() {
     return sReleasedTexImageBuffer;
 }
 
-status_t GLConsumer::acquireBufferLocked(BufferItem *item,
-        nsecs_t presentWhen, uint64_t maxFrameNumber) {
-    status_t err = ConsumerBase::acquireBufferLocked(item, presentWhen,
-            maxFrameNumber);
+status_t GLConsumer::acquireBufferLocked(BufferQueue::BufferItem *item,
+        nsecs_t presentWhen) {
+    status_t err = ConsumerBase::acquireBufferLocked(item, presentWhen);
     if (err != NO_ERROR) {
         return err;
     }
@@ -375,7 +374,7 @@ status_t GLConsumer::releaseBufferLocked(int buf,
     return err;
 }
 
-status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item)
+status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
 {
     status_t err = NO_ERROR;
 
diff --git a/libs/gui/IGraphicBufferConsumer.cpp b/libs/gui/IGraphicBufferConsumer.cpp
index 7ae82e0..dde8275 100644
--- a/libs/gui/IGraphicBufferConsumer.cpp
+++ b/libs/gui/IGraphicBufferConsumer.cpp
@@ -33,6 +33,163 @@
 #include <system/window.h>
 
 namespace android {
+// ---------------------------------------------------------------------------
+
+IGraphicBufferConsumer::BufferItem::BufferItem() :
+    mTransform(0),
+    mScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
+    mTimestamp(0),
+    mIsAutoTimestamp(false),
+    mDataSpace(HAL_DATASPACE_UNKNOWN),
+    mFrameNumber(0),
+    mBuf(INVALID_BUFFER_SLOT),
+    mIsDroppable(false),
+    mAcquireCalled(false),
+    mTransformToDisplayInverse(false) {
+    mCrop.makeInvalid();
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getPodSize() const {
+    size_t c =  sizeof(mCrop) +
+            sizeof(mTransform) +
+            sizeof(mScalingMode) +
+            sizeof(mTimestamp) +
+            sizeof(mIsAutoTimestamp) +
+            sizeof(mDataSpace) +
+            sizeof(mFrameNumber) +
+            sizeof(mBuf) +
+            sizeof(mIsDroppable) +
+            sizeof(mAcquireCalled) +
+            sizeof(mTransformToDisplayInverse);
+    return c;
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getFlattenedSize() const {
+    size_t c = 0;
+    if (mGraphicBuffer != 0) {
+        c += mGraphicBuffer->getFlattenedSize();
+        c = FlattenableUtils::align<4>(c);
+    }
+    if (mFence != 0) {
+        c += mFence->getFlattenedSize();
+        c = FlattenableUtils::align<4>(c);
+    }
+    return sizeof(int32_t) + c + getPodSize();
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getFdCount() const {
+    size_t c = 0;
+    if (mGraphicBuffer != 0) {
+        c += mGraphicBuffer->getFdCount();
+    }
+    if (mFence != 0) {
+        c += mFence->getFdCount();
+    }
+    return c;
+}
+
+static void writeBoolAsInt(void*& buffer, size_t& size, bool b) {
+    FlattenableUtils::write(buffer, size, static_cast<int32_t>(b));
+}
+
+static bool readBoolFromInt(void const*& buffer, size_t& size) {
+    int32_t i;
+    FlattenableUtils::read(buffer, size, i);
+    return static_cast<bool>(i);
+}
+
+status_t IGraphicBufferConsumer::BufferItem::flatten(
+        void*& buffer, size_t& size, int*& fds, size_t& count) const {
+
+    // make sure we have enough space
+    if (size < BufferItem::getFlattenedSize()) {
+        return NO_MEMORY;
+    }
+
+    // content flags are stored first
+    uint32_t& flags = *static_cast<uint32_t*>(buffer);
+
+    // advance the pointer
+    FlattenableUtils::advance(buffer, size, sizeof(uint32_t));
+
+    flags = 0;
+    if (mGraphicBuffer != 0) {
+        status_t err = mGraphicBuffer->flatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+        flags |= 1;
+    }
+    if (mFence != 0) {
+        status_t err = mFence->flatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+        flags |= 2;
+    }
+
+    // check we have enough space (in case flattening the fence/graphicbuffer lied to us)
+    if (size < getPodSize()) {
+        return NO_MEMORY;
+    }
+
+    FlattenableUtils::write(buffer, size, mCrop);
+    FlattenableUtils::write(buffer, size, mTransform);
+    FlattenableUtils::write(buffer, size, mScalingMode);
+    FlattenableUtils::write(buffer, size, mTimestamp);
+    writeBoolAsInt(buffer, size, mIsAutoTimestamp);
+    FlattenableUtils::write(buffer, size, mDataSpace);
+    FlattenableUtils::write(buffer, size, mFrameNumber);
+    FlattenableUtils::write(buffer, size, mBuf);
+    writeBoolAsInt(buffer, size, mIsDroppable);
+    writeBoolAsInt(buffer, size, mAcquireCalled);
+    writeBoolAsInt(buffer, size, mTransformToDisplayInverse);
+
+    return NO_ERROR;
+}
+
+status_t IGraphicBufferConsumer::BufferItem::unflatten(
+        void const*& buffer, size_t& size, int const*& fds, size_t& count) {
+
+    if (size < sizeof(uint32_t))
+        return NO_MEMORY;
+
+    uint32_t flags = 0;
+    FlattenableUtils::read(buffer, size, flags);
+
+    if (flags & 1) {
+        mGraphicBuffer = new GraphicBuffer();
+        status_t err = mGraphicBuffer->unflatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+    }
+
+    if (flags & 2) {
+        mFence = new Fence();
+        status_t err = mFence->unflatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+    }
+
+    // check we have enough space
+    if (size < getPodSize()) {
+        return NO_MEMORY;
+    }
+
+    FlattenableUtils::read(buffer, size, mCrop);
+    FlattenableUtils::read(buffer, size, mTransform);
+    FlattenableUtils::read(buffer, size, mScalingMode);
+    FlattenableUtils::read(buffer, size, mTimestamp);
+    mIsAutoTimestamp = readBoolFromInt(buffer, size);
+    FlattenableUtils::read(buffer, size, mDataSpace);
+    FlattenableUtils::read(buffer, size, mFrameNumber);
+    FlattenableUtils::read(buffer, size, mBuf);
+    mIsDroppable = readBoolFromInt(buffer, size);
+    mAcquireCalled = readBoolFromInt(buffer, size);
+    mTransformToDisplayInverse = readBoolFromInt(buffer, size);
+
+    return NO_ERROR;
+}
+
+// ---------------------------------------------------------------------------
 
 enum {
     ACQUIRE_BUFFER = IBinder::FIRST_CALL_TRANSACTION,
@@ -66,12 +223,10 @@ public:
 
     virtual ~BpGraphicBufferConsumer();
 
-    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen,
-            uint64_t maxFrameNumber) {
+    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
         data.writeInt64(presentWhen);
-        data.writeUint64(maxFrameNumber);
         status_t result = remote()->transact(ACQUIRE_BUFFER, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -297,8 +452,7 @@ status_t BnGraphicBufferConsumer::onTransact(
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             BufferItem item;
             int64_t presentWhen = data.readInt64();
-            uint64_t maxFrameNumber = data.readUint64();
-            status_t result = acquireBuffer(&item, presentWhen, maxFrameNumber);
+            status_t result = acquireBuffer(&item, presentWhen);
             status_t err = reply->write(item);
             if (err) return err;
             reply->writeInt32(result);
diff --git a/libs/gui/MediatekHacks.cpp b/libs/gui/MediatekHacks.cpp
new file mode 100644
index 0000000..2514984
--- /dev/null
+++ b/libs/gui/MediatekHacks.cpp
@@ -0,0 +1,16 @@
+#include <gui/IGraphicBufferAlloc.h>
+extern "C" {
+    void _ZN7android11BufferQueueC1ERKNS_2spINS_19IGraphicBufferAllocEEE(const android::sp<android::IGraphicBufferAlloc>& allocator);
+    void _ZN7android11BufferQueueC2ERKNS_2spINS_19IGraphicBufferAllocEEE(const android::sp<android::IGraphicBufferAlloc>& allocator);
+
+    void _ZN7android11BufferQueueC1ERKNS_2spINS_19IGraphicBufferAllocEEE(const android::sp<android::IGraphicBufferAlloc>& allocator){
+        _ZN7android11BufferQueueC2ERKNS_2spINS_19IGraphicBufferAllocEEE(allocator);
+    }
+
+    void _ZN7android14SurfaceControl8setLayerEi(int32_t);
+    void _ZN7android14SurfaceControl8setLayerEj(uint32_t);
+
+    void _ZN7android14SurfaceControl8setLayerEi(int32_t layer){
+        _ZN7android14SurfaceControl8setLayerEj(static_cast<uint32_t>(layer));
+    }
+}
diff --git a/libs/gui/SensorManager.cpp b/libs/gui/SensorManager.cpp
index 33608b5..08ce287 100644
--- a/libs/gui/SensorManager.cpp
+++ b/libs/gui/SensorManager.cpp
@@ -39,6 +39,32 @@ namespace android {
 android::Mutex android::SensorManager::sLock;
 std::map<String16, SensorManager*> android::SensorManager::sPackageInstances;
 
+#ifdef MTK_HARDWARE
+
+static const String8 packageName8("");
+
+
+// be compatible with MTK Lollipop blobs
+extern "C" {
+    android::Mutex _ZN7android9SingletonINS_13SensorManagerEE5sLockE;
+    SensorManager *_ZN7android9SingletonINS_13SensorManagerEE9sInstanceE = nullptr;
+}
+
+
+// compatible ctor
+SensorManager::SensorManager()
+    : mSensorList(0), mOpPackageName("")
+{
+    // okay we're not locked here, but it's not needed during construction
+    assertStateLocked();
+}
+
+
+sp<SensorEventQueue> SensorManager::createEventQueue() {
+	return createEventQueue(packageName8, 0);
+}
+#endif  // MTK_HARDWARE
+
 SensorManager& SensorManager::getInstanceForPackage(const String16& packageName) {
     Mutex::Autolock _l(sLock);
     SensorManager* sensorManager;
diff --git a/libs/gui/StreamSplitter.cpp b/libs/gui/StreamSplitter.cpp
index 43f9214..0823d45 100644
--- a/libs/gui/StreamSplitter.cpp
+++ b/libs/gui/StreamSplitter.cpp
@@ -124,7 +124,7 @@ void StreamSplitter::onFrameAvailable(const BufferItem& /* item */) {
     ++mOutstandingBuffers;
 
     // Acquire and detach the buffer from the input
-    BufferItem bufferItem;
+    IGraphicBufferConsumer::BufferItem bufferItem;
     status_t status = mInput->acquireBuffer(&bufferItem, /* presentWhen */ 0);
     LOG_ALWAYS_FATAL_IF(status != NO_ERROR,
             "acquiring buffer from input failed (%d)", status);
diff --git a/libs/gui/tests/BufferQueue_test.cpp b/libs/gui/tests/BufferQueue_test.cpp
index 1a54875..62be458 100644
--- a/libs/gui/tests/BufferQueue_test.cpp
+++ b/libs/gui/tests/BufferQueue_test.cpp
@@ -128,7 +128,7 @@ TEST_F(BufferQueueTest, BufferQueueInAnotherProcess) {
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
 
     uint32_t* dataOut;
@@ -153,7 +153,7 @@ TEST_F(BufferQueueTest, AcquireBuffer_ExceedsMaxAcquireCount_Fails) {
     IGraphicBufferProducer::QueueBufferInput qbi(0, false,
             HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     for (int i = 0; i < 2; i++) {
         ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
@@ -250,7 +250,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
 
     uint32_t* dataOut;
@@ -285,7 +285,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
             BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
     ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(0)); // Not acquired
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
 
     ASSERT_EQ(OK, mConsumer->detachBuffer(item.mBuf));
@@ -346,7 +346,7 @@ TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
     ASSERT_EQ(OK, mConsumer->detachBuffer(item.mBuf));
 
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index a8eb67b..3f84d92 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -43,7 +43,17 @@ LOCAL_SRC_FILES := \
 	PixelFormat.cpp \
 	Rect.cpp \
 	Region.cpp \
-	UiConfig.cpp
+	UiConfig.cpp \
+
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+	mediatek/Fence.cpp \
+	mediatek/IDumpTunnel.cpp \
+	mediatek/RefBaseDump.cpp
+
+# just make everything compile for now... cleanups later
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
+endif
 
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
@@ -52,6 +62,11 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	liblog
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SHARED_LIBRARIES += \
+	libbinder
+endif
+
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 0580e16..0b871b9 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -77,6 +77,28 @@ status_t GraphicBufferMapper::unregisterBuffer(buffer_handle_t handle)
     return err;
 }
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
+extern status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(buffer_handle_t, uint32_t, const Rect&, android_ycbcr *);
+
+
+status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
+        int usage, const Rect& bounds, void** vaddr)
+{
+    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
+}
+
+
+status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handleiRKNS_4RectEP13android_ycbcr(buffer_handle_t handle,
+        int usage, const Rect& bounds, android_ycbcr *ycbcr)
+{
+    return _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(handle, static_cast<uint32_t>(usage), bounds, ycbcr);
+}
+}
+#endif
+
 status_t GraphicBufferMapper::lock(buffer_handle_t handle,
         uint32_t usage, const Rect& bounds, void** vaddr)
 {
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 0000000..c604cd0
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,59 @@
+#define LOG_TAG "Fence"
+
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGD("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                int ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                int ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                String8 msg = String8::format(
+                    "sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%d.%06d)",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *(uint32_t *)pt_info->driver_data, ts_sec, ts_usec);
+                ALOGD("%s", msg.string());
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 0000000..d52f72a
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,114 @@
+#define LOG_TAG "DumpTunnel"
+
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    // need to use different path for 32/64 env
+#ifdef __LP64__
+    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
+#else
+    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
+#endif
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 0000000..333add4
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,111 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+#define RBD_LOGV(x, ...)
+#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+#define RBD_LOGW(x, ...)
+#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/process_name.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+
+RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
+    : mMonitor(pMonitor) {
+}
+
+RefBaseDump::~RefBaseDump() {
+}
+
+status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
+    return mMonitor->dump(result);
+}
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+    mDump = new RefBaseDump(this);
+    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
+}
+
+RefBaseMonitor::~RefBaseMonitor() {
+    RBD_LOGI("RefBaseMonitor dtor - %p", this);
+    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
+}
+
+status_t RefBaseMonitor::monitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    RbList.add(pRb, 0);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    RbList.removeItem(pRb);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::dump(String8& result) {
+    int listSz;
+    RefBase *pRb;
+    Mutex::Autolock _l(mMutex);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = RbList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (int i = 0; i < listSz; i++) {
+        pRb = RbList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+}
diff --git a/libs/ui/mediatek/test/Android.mk b/libs/ui/mediatek/test/Android.mk
new file mode 100755
index 0000000..82e7389
--- /dev/null
+++ b/libs/ui/mediatek/test/Android.mk
@@ -0,0 +1 @@
+#barrier
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
new file mode 100755
index 0000000..79edcbc
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
@@ -0,0 +1,15 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    RefBaseDumpTunnel.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libui
+
+LOCAL_MODULE:= test-RefBaseDumpTunnel
+
+LOCAL_MODULE_TAGS := tests
+
+include $(BUILD_EXECUTABLE)
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
new file mode 100644
index 0000000..f935808
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
@@ -0,0 +1,105 @@
+#include <stdio.h>
+#include <time.h>
+#include <utils/StrongPointer.h>
+#include "RefBaseDumpTunnel.h"
+
+using namespace android;
+
+void RefBaseMonitorTest_Assignment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    sp<RefBaseTest> sp2;
+    //printf("[1]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+         sp2 = sp1;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+}
+
+void RefBaseMonitorTest_CtorDtor(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    RefBaseTest *rbtmp;
+    //printf("[2]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        rbtmp = new RefBaseTest();
+        delete rbtmp;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorTest_CtorDtorAssgnment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    //printf("[3]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        sp1 = new RefBaseTest();
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorSubTest (int testRound, int testCntPerRound, void (*testFunc)(int, struct timespec *, struct timespec *)) {
+    struct timespec tsS;
+    struct timespec tsE;
+    int tmp;
+    int totalCnt;
+    int timeWithTracking = 0;
+
+    for(int j = 0; j < testRound; j++) {
+        //printf("Rnd: %d",j);
+        (*testFunc)(testCntPerRound, &tsS, &tsE);
+
+        tmp = tsE.tv_nsec - tsS.tv_nsec;
+        if (tmp < 0) {
+            tmp = 1000000000L + tsE.tv_nsec - tsS.tv_nsec;
+        }
+        timeWithTracking += tmp;
+        //printf("with RefBaseTracking....D:%d(ns)\n",tmp);
+    }
+    totalCnt = testRound * testCntPerRound;
+    printf("%12d(ns) = TotalTime: %12d(ns) / TestCnt: %d \n", timeWithTracking / totalCnt, timeWithTracking, totalCnt);
+
+}
+
+void RefBaseMonitorTest(int recCount, int testRound, int testCntPerRound) {
+    int tmp = recCount;
+    if (recCount == 0) {
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_Assignment);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtor);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtorAssgnment);
+    } else {
+        recCount--;
+        RefBaseMonitorTest(recCount, testRound, testCntPerRound);
+    }
+    printf("(stack:%d)", tmp);
+}
+
+int main(int argc, char** argv) {
+    int recLv;
+    int testRound;
+    int testCntPerRound;
+    int recCntTime;
+
+    if (argc == 5) {
+        sscanf(argv[1], "%d", &recLv);
+        sscanf(argv[2], "%d", &recCntTime);
+        sscanf(argv[3], "%d", &testRound);
+        sscanf(argv[4], "%d", &testCntPerRound);
+        if ((recLv >= 0) && (recCntTime > 0) && (testRound > 0) && (testCntPerRound > 0)) {
+            for (int i = 0; i < recCntTime; i++) {
+                printf("\nrec[ n + %d ]\n", i + recLv);
+                RefBaseMonitorTest(i + recLv, testRound, testCntPerRound);
+            }
+            printf("\n\n");
+            return 0;
+        }
+    }
+    printf("test-RefBaseDumpTunnel recLv recTimes testRnd testCntPerRnd\n");
+    return 0;
+}
+
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
new file mode 100644
index 0000000..5ba0025
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
@@ -0,0 +1,17 @@
+#include <utils/RefBase.h>
+#include <ui/mediatek/RefBaseDumpTunnel.h>
+
+namespace android
+{
+
+class RefBaseTest: public RefBase{
+    public:
+        RefBaseTest(){
+            RefBaseMonitor::getInstance().monitor(this);
+        }
+        ~RefBaseTest(){
+            RefBaseMonitor::getInstance().unmonitor(this);
+        }
+};
+
+};
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 2f6bc79..c0e6054 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -151,11 +151,13 @@ static const extention_map_t sExtensionMap[] = {
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
 
+#ifndef MTK_HARDWARE
     // EGL_NV_system_time
     { "eglGetSystemTimeFrequencyNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
     { "eglGetSystemTimeNV",
             (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -1835,6 +1837,7 @@ EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
 // ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
+#ifndef MTK_HARDWARE
 EGLuint64NV eglGetSystemTimeFrequencyNV()
 {
     clearError();
@@ -1870,6 +1873,7 @@ EGLuint64NV eglGetSystemTimeNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
+#endif
 
 // ----------------------------------------------------------------------------
 // Partial update extension
diff --git a/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp b/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
index 70af656..55d9d26 100644
--- a/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
@@ -88,7 +88,7 @@ status_t FramebufferSurface::advanceFrame() {
 status_t FramebufferSurface::nextBuffer(sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence) {
     Mutex::Autolock lock(mMutex);
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
     status_t err = acquireBufferLocked(&item, 0);
     if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
         outBuffer = mCurrentBuffer;
diff --git a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
index 5fd2136..99fe1f1 100644
--- a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
@@ -446,7 +446,7 @@ status_t VirtualDisplaySurface::queueBuffer(int pslot,
         // Now acquire the buffer from the scratch pool -- should be the same
         // slot and fence as we just queued.
         Mutex::Autolock lock(mMutex);
-        BufferItem item;
+        BufferQueue::BufferItem item;
         result = acquireBufferLocked(&item, 0);
         if (result != NO_ERROR)
             return result;
diff --git a/services/surfaceflinger/DisplayUtils.cpp b/services/surfaceflinger/DisplayUtils.cpp
index e618e89..1209920 100644
--- a/services/surfaceflinger/DisplayUtils.cpp
+++ b/services/surfaceflinger/DisplayUtils.cpp
@@ -178,6 +178,11 @@ bool DisplayUtils::canAllocateHwcDisplayIdForVDS(int usage) {
     // on AOSP builds with QTI_BSP disabled, we should allocate hwc display id for virtual display
     int flag_mask = 0xffffffff;
 
+#ifdef MTK_HARDWARE
+    // xen0n: seems necessary for at least Meizu MX4's hwcomposer to not crash
+    flag_mask = 0;
+#endif
+
 #ifdef QTI_BSP
 #ifdef FORCE_HWC_COPY_FOR_VIRTUAL_DISPLAYS
 #ifdef SDM_TARGET
diff --git a/services/surfaceflinger/Layer.h b/services/surfaceflinger/Layer.h
index 0d6ec41..0a1af06 100644
--- a/services/surfaceflinger/Layer.h
+++ b/services/surfaceflinger/Layer.h
@@ -380,9 +380,9 @@ protected:
 
 private:
     // Interface implementation for SurfaceFlingerConsumer::ContentsChangedListener
-    virtual void onFrameAvailable(const BufferItem& item) override;
-    virtual void onFrameReplaced(const BufferItem& item) override;
-    virtual void onSidebandStreamChanged() override;
+    virtual void onFrameAvailable(const BufferItem& item);
+    virtual void onFrameReplaced(const BufferItem& item);
+    virtual void onSidebandStreamChanged();
 
     void commitTransaction();
 
diff --git a/services/surfaceflinger/SurfaceFlingerConsumer.cpp b/services/surfaceflinger/SurfaceFlingerConsumer.cpp
index ed1f31b..9bdfa7c 100644
--- a/services/surfaceflinger/SurfaceFlingerConsumer.cpp
+++ b/services/surfaceflinger/SurfaceFlingerConsumer.cpp
@@ -34,6 +34,7 @@ namespace android {
 status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
         const DispSync& dispSync, uint64_t maxFrameNumber)
 {
+    (void)maxFrameNumber;
     ATRACE_CALL();
     ALOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -49,13 +50,12 @@ status_t SurfaceFlingerConsumer::updateTexImage(BufferRejecter* rejecter,
         return err;
     }
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     // Acquire the next buffer.
     // In asynchronous mode the list is guaranteed to be one buffer
     // deep, while in synchronous mode we use the oldest buffer.
-    err = acquireBufferLocked(&item, computeExpectedPresent(dispSync),
-            maxFrameNumber);
+    err = acquireBufferLocked(&item, computeExpectedPresent(dispSync));
     if (err != NO_ERROR) {
         if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
             err = NO_ERROR;
@@ -104,13 +104,11 @@ status_t SurfaceFlingerConsumer::bindTextureImage()
     return bindTextureImageLocked();
 }
 
-status_t SurfaceFlingerConsumer::acquireBufferLocked(BufferItem* item,
-        nsecs_t presentWhen, uint64_t maxFrameNumber) {
-    status_t result = GLConsumer::acquireBufferLocked(item, presentWhen,
-            maxFrameNumber);
+status_t SurfaceFlingerConsumer::acquireBufferLocked(BufferQueue::BufferItem* item,
+        nsecs_t presentWhen) {
+    status_t result = GLConsumer::acquireBufferLocked(item, presentWhen);
     if (result == NO_ERROR) {
         mTransformToDisplayInverse = item->mTransformToDisplayInverse;
-        mSurfaceDamage = item->mSurfaceDamage;
     }
     return result;
 }
diff --git a/services/surfaceflinger/SurfaceFlingerConsumer.h b/services/surfaceflinger/SurfaceFlingerConsumer.h
index 779e5b7..8ad6b8c 100644
--- a/services/surfaceflinger/SurfaceFlingerConsumer.h
+++ b/services/surfaceflinger/SurfaceFlingerConsumer.h
@@ -49,8 +49,7 @@ public:
         virtual ~BufferRejecter() { }
     };
 
-    virtual status_t acquireBufferLocked(BufferItem *item, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0) override;
+    virtual status_t acquireBufferLocked(BufferQueue::BufferItem *item, nsecs_t presentWhen);
 
     // This version of updateTexImage() takes a functor that may be used to
     // reject the newly acquired buffer.  Unlike the GLConsumer version,
-- 
2.7.4

